<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GALATAY</title>
  <style>
    :root{
      /* Game Boy-ish scale knobs */
      --tile: 16px;       /* tile size */
      --grid: 9;          /* 9x9 */
      --scale: 3;         /* pixel upscaling */
      --room-px: calc(var(--tile) * var(--grid));
      --room-scale: calc(var(--room-px) * var(--scale));
      --ink: #111;
      --paper: #f7f7f7;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--paper);
      color: var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: none;
    }

    /* Layout: room centered, extra space for UI */
    .page {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .frame {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 20px;
      align-items: center;
      width: min(980px, 96vw);
    }

    .side {
      font-size: 14px;
      line-height: 1.4;
      opacity: 0.85;
      user-select: none;
    }

    .panel {
      border: 2px solid var(--ink);
      padding: 12px 14px;
      background: #fff;
      box-shadow: 6px 6px 0 var(--ink);
    }

    @media (max-width: 720px) {
      .side {
        display: none;
      }
    }

    /* Canvas wrapper gives the "Game Boy screen" feel */
    .screen {
      width: var(--room-scale);
      height: var(--room-scale);
      border: 3px solid var(--ink);
      background: #fff;
      box-shadow: 10px 10px 0 var(--ink);
      image-rendering: pixelated;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: pixelated;
    }

    .hint {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.8;
    }

    .kbd {
      display: inline-block;
      border: 1px solid var(--ink);
      padding: 1px 6px;
      background: #fff;
      box-shadow: 2px 2px 0 var(--ink);
      margin: 0 2px;
    }

    .controls {
      margin-top: 10px;
      display: grid;
      gap: 6px;
      justify-content: center;
      user-select: none;
    }

    .controls-row {
      display: grid;
      grid-auto-flow: column;
      gap: 6px;
      justify-content: center;
    }

    .ctrl-btn {
      width: 66px;
      height: 66px;
      border: 2px solid var(--ink);
      background: #fff;
      box-shadow: 3px 3px 0 var(--ink);
      font-size: 30px;
      line-height: 1;
      cursor: pointer;
      touch-action: manipulation;
      user-select: none;
    }

    .ctrl-btn:active {
      transform: translate(1px, 1px);
      box-shadow: 2px 2px 0 var(--ink);
    }

    #room6-debug
    {
      display:none;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="frame">
      <div class="side panel">
        <div><strong>Instructions</strong></div>
        <div class="hint">Find the watermelon. üçâ</div>
        <div class="hint">Controls:</div>
        <hr />
        <div>Move:</div><br>
        <div>
          <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span>
          <br>
          <span class="kbd">‚Üë</span><span class="kbd">‚Üê</span><span class="kbd">‚Üì</span><span class="kbd">‚Üí</span>
        </div>
      </div>

      <div>
        <div class="screen">
          <canvas id="game" width="144" height="144"></canvas>
        </div>
        <div id="room-label" class="hint">Room 1</div>
        <div class="hint">9√ó9 tiles @ 16px (canvas is 144√ó144, scaled up).</div>
        <div class="controls" aria-label="On-screen controls">
          <div class="controls-row">
            <button class="ctrl-btn" data-dir="up" aria-label="Move up">‚Üë</button>
          </div>
          <div class="controls-row">
            <button class="ctrl-btn" data-dir="left" aria-label="Move left">‚Üê</button>
            <button class="ctrl-btn" data-dir="down" aria-label="Move down">‚Üì</button>
            <button class="ctrl-btn" data-dir="right" aria-label="Move right">‚Üí</button>
          </div>
        </div>
      </div>

      <div class="side panel">
        <div><strong>Debug</strong></div>
        <div id="status" class="hint">x: 4, y: 4</div>
        <div id="room6-debug" class="hint">room6Path: none</div>
        <hr />
        <div class="hint">
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Config =====
    const TILE = 16;
    const GRID = 9;
    const W = TILE * GRID;
    const H = TILE * GRID;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    // Keep canvas "true size" pixel art
    canvas.width = W;
    canvas.height = H;

    const statusEl = document.getElementById("status");
    const roomLabelEl = document.getElementById("room-label");
    const room6DebugEl = document.getElementById("room6-debug");

    const playerImg = new Image();
    playerImg.src = "player.png";
    let playerImgReady = false;
    playerImg.onload = () => {
      playerImgReady = true;
    };

    const treeImg = new Image();
    treeImg.src = "tree.png";
    let treeImgReady = false;
    treeImg.onload = () => {
      treeImgReady = true;
    };

    const watermelonImg = new Image();
    watermelonImg.src = "watermelon.png";
    let watermelonImgReady = false;
    watermelonImg.onload = () => {
      watermelonImgReady = true;
    };

    // Simple room: 0 = floor, 1 = wall, 2 = door, 3 = button
    const DOOR = 2;
    const BUTTON = 3;
    const MID = Math.floor(GRID / 2);
    const ROOM4_BUTTON = { x: MID, y: MID };

    function makeRoom(doors) {
      const room = [];
      for (let y = 0; y < GRID; y++) {
        room[y] = [];
        for (let x = 0; x < GRID; x++) {
          const isEdge = (x === 0 || y === 0 || x === GRID - 1 || y === GRID - 1);
          room[y][x] = isEdge ? 1 : 0;
        }
      }
      for (const door of doors) room[door.y][door.x] = DOOR;
      return room;
    }

    const roomDefs = [
      {
        label: 1,
        floor: "#239063",
        doors: [
          { x: MID, y: 0, target: 1, spawnX: MID, spawnY: GRID - 2 },
        ],
      },
      {
        label: 2,
        floor: "#00e436",
        doors: [
          { x: MID, y: GRID - 1, target: 0, spawnX: MID, spawnY: 1 },
          { x: 0, y: MID, target: 2, spawnX: GRID - 2, spawnY: MID },
          { x: GRID - 1, y: MID, target: 3, spawnX: 1, spawnY: MID },
        ],
      },
      {
        label: 3,
        floor: "#ffec27",
        doors: [
          { x: GRID - 1, y: MID, target: 1, spawnX: 1, spawnY: MID },
          { x: MID, y: GRID - 1, target: 5, spawnX: MID, spawnY: 1 },
        ],
      },
      {
        label: 4,
        floor: "#ff77a8",
        doors: [
          { x: 0, y: MID, target: 1, spawnX: GRID - 2, spawnY: MID },
        ],
      },
      {
        label: 6,
        floor: "#83769c",
        doors: [
          { x: MID, y: GRID - 1, target: 1, spawnX: MID, spawnY: 1 },
          { x: MID, y: 0, target: 0, spawnX: MID, spawnY: GRID - 2 },
        ],
      },
      {
        label: 7,
        floor: "#ffccaa",
        doors: [
          { x: MID, y: 0, target: 2, spawnX: MID, spawnY: GRID - 2 },
          { x: GRID - 1, y: MID, target: 0, spawnX: 1, spawnY: MID },
        ],
      },
      {
        label: 8,
        floor: "#7e2553",
        doors: [
          { x: GRID - 1, y: MID, target: 0, spawnX: 1, spawnY: MID },
        ],
      },
      {
        label: 9,
        floor: "#c2c3c7",
        doors: [
          { x: MID, y: GRID - 1, target: 4, spawnX: MID, spawnY: 1 },
        ],
      },
      {
        label: 10,
        floor: "#ab5236",
        doors: [
          { x: MID, y: GRID - 1, target: 4, spawnX: MID, spawnY: 1 },
        ],
      },
    ];

    const rooms = roomDefs.map((def) => makeRoom(def.doors));
    const room1TreeBlocks = new Set([
      "1,1","2,1","1,2","2,2",
      "6,1","7,1","6,2","7,2",
      "1,6","2,6","1,7","2,7",
      "6,6","7,6","6,7","7,7",
    ]);
    for (let y = 3; y <= 5; y++) {
      for (let x = 3; x <= 5; x++) {
        rooms[4][y][x] = 1;
      }
    }
    let roomIndex = 0;

    // Player in tile coords (center-ish)
    const player = {
      x: 4,
      y: 4,
      // for smooth-ish movement later we could add px coords;
      // keep it tile-based for this MVP
    };

    const keys = new Set();
    let queuedMove = null;
    let heldDir = null;

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"].includes(k)) {
        e.preventDefault();
        keys.add(k);
      }
    });

    window.addEventListener("keyup", (e) => {
      keys.delete(e.key.toLowerCase());
    });

    document.querySelectorAll(".ctrl-btn").forEach((btn) => {
      const dir = btn.dataset.dir;
      const vec =
        dir === "up" ? { dx: 0, dy: -1 } :
        dir === "down" ? { dx: 0, dy: 1 } :
        dir === "left" ? { dx: -1, dy: 0 } :
        { dx: 1, dy: 0 };

      btn.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        heldDir = { dx: vec.dx, dy: vec.dy };
      });

      const clearHeld = () => {
        heldDir = null;
      };

      btn.addEventListener("pointerup", clearHeld);
      btn.addEventListener("pointerleave", clearHeld);
      btn.addEventListener("pointercancel", clearHeld);
    });

    function isSolid(tx, ty) {
      if (tx < 0 || ty < 0 || tx >= GRID || ty >= GRID) return true;
      if (getDoorAt(roomIndex, tx, ty)) return false;
      if (roomIndex === 0 && room1TreeBlocks.has(`${tx},${ty}`)) return true;
      if (roomIndex === 8 && room10Watermelon && tx === MID && ty === MID) return true;
      return rooms[roomIndex][ty][tx] === 1;
    }

    // Move once per key press repeat is fine for MVP; add cooldown for ‚Äúgrid step‚Äù feel.
    let moveCooldown = 0;
    const MOVE_DELAY = 90; // ms
    const HOP_DURATION = 120; // ms
    let hopTimer = 0;

    // Simple fade transition state
    const transition = {
      active: false,
      alpha: 0,
      dir: 1,
      targetRoom: 0,
      targetX: 0,
      targetY: 0,
    };
    const FADE_DURATION = 250; // ms
    let room4ButtonActive = false;
    let room3Visited = false;
    let room1LeftDoorUnlocked = false;
    let room6Path = null;
    let room10Discovered = false;
    let room10LinkUnlocked = false;
    let room10Watermelon = false;
    let facing = 1;

    let last = performance.now();
    function loop(now) {
      const dt = now - last;
      last = now;

      if (!transition.active) {
        moveCooldown -= dt;
        if (moveCooldown <= 0) {
          let dx =
            (keys.has("arrowright") || keys.has("d") ? 1 : 0) +
            (keys.has("arrowleft")  || keys.has("a") ? -1 : 0);
          let dy =
            (keys.has("arrowdown") || keys.has("s") ? 1 : 0) +
            (keys.has("arrowup")   || keys.has("w") ? -1 : 0);

          if (dx === 0 && dy === 0 && heldDir) {
            dx = heldDir.dx;
            dy = heldDir.dy;
          } else if (dx === 0 && dy === 0 && queuedMove) {
            dx = queuedMove.dx;
            dy = queuedMove.dy;
            queuedMove = null;
          }

          // Prefer horizontal if both held (simple rule)
          let nx = player.x;
          let ny = player.y;

          if (dx !== 0) nx = player.x + Math.sign(dx);
          else if (dy !== 0) ny = player.y + Math.sign(dy);

          if ((nx !== player.x || ny !== player.y) && !isSolid(nx, ny)) {
            if (nx !== player.x) {
              facing = nx > player.x ? 1 : -1;
            }
            player.x = nx;
            player.y = ny;
            moveCooldown = MOVE_DELAY;
            hopTimer = HOP_DURATION;
            if (
              roomIndex === 3 &&
              player.x === ROOM4_BUTTON.x &&
              player.y === ROOM4_BUTTON.y &&
              room3Visited
            ) {
              room4ButtonActive = true;
            }
            if (roomIndex === 4 && player.y === MID) {
              if (player.x === 1 || player.x === 2) room6Path = "left";
              if (player.x === 6 || player.x === 7) room6Path = "right";
            }
            tryDoorTransition();
          }
        }
      } else {
        transition.alpha += (dt / FADE_DURATION) * transition.dir;
        if (transition.dir > 0 && transition.alpha >= 1) {
          if (roomIndex === 5 && transition.targetRoom === 0) {
            room1LeftDoorUnlocked = true;
          }
          if (transition.targetRoom === 8) {
            room10Discovered = true;
          }
          if (roomIndex === 6 && transition.targetRoom === 8) {
            room10LinkUnlocked = true;
            room10Watermelon = true;
          }
          roomIndex = transition.targetRoom;
          player.x = transition.targetX;
          player.y = transition.targetY;
          if (roomIndex === 2) {
            room3Visited = true;
          }
          transition.alpha = 1;
          transition.dir = -1;
        } else if (transition.dir < 0 && transition.alpha <= 0) {
          transition.alpha = 0;
          transition.active = false;
        }
      }

      if (hopTimer > 0) {
        hopTimer = Math.max(0, hopTimer - dt);
      }

      draw();
      requestAnimationFrame(loop);
    }

    function tryDoorTransition() {
      const door = getDoorAt(roomIndex, player.x, player.y);
      if (!door) return;

      let target = door.target;
      if (roomIndex === 1 && player.x === 0 && player.y === MID) {
        target = 2;
      } else if (roomIndex === 4 && player.x === MID && player.y === 0) {
        if (room6Path === "left") target = 7;
        else if (room6Path === "right") target = 8;
      }

      transition.active = true;
      transition.alpha = 0;
      transition.dir = 1;
      transition.targetRoom = target;
      transition.targetX = door.spawnX;
      transition.targetY = door.spawnY;
    }

    function getDoorAt(rIndex, x, y) {
      let doors = roomDefs[rIndex].doors;
      if (rIndex === 1 && room4ButtonActive) {
        doors = doors.concat([
          { x: MID, y: 0, target: 4, spawnX: MID, spawnY: GRID - 2 },
        ]);
      }
      if (rIndex === 6 && room10Discovered) {
        doors = doors.concat([
          { x: 0, y: MID, target: 8, spawnX: GRID - 2, spawnY: MID },
        ]);
      }
      if (rIndex === 8 && room10LinkUnlocked) {
        doors = doors.concat([
          { x: GRID - 1, y: MID, target: 6, spawnX: 1, spawnY: MID },
        ]);
      }
      if (rIndex === 0 && room1LeftDoorUnlocked) {
        doors = doors.concat([
          { x: 0, y: MID, target: 6, spawnX: GRID - 2, spawnY: MID },
        ]);
      }
      return doors.find((d) => d.x === x && d.y === y);
    }

    function draw() {
      // Clear
      ctx.clearRect(0, 0, W, H);
      ctx.imageSmoothingEnabled = false;

      const roomLabel = String(roomDefs[roomIndex].label);
      const floorBase = roomDefs[roomIndex].floor;
      const floorShade = "rgba(0,0,0,0.18)";
      const numberShade = "rgba(0,0,0,0.22)";

      // Draw floors
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          const t = rooms[roomIndex][y][x];
          if (t !== 0) continue;
          ctx.fillStyle = floorBase;
          ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
          if (roomDefs[roomIndex].label !== 1) {
            const jitter = (x * 17 + y * 31 + roomDefs[roomIndex].label * 13) % 5;
            const offset = jitter === 0 ? 1 : 0;
            if ((x + y + offset) % 2 === 0) {
              ctx.fillStyle = "rgba(0,0,0,0.12)";
              ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
            }
          }
        }
      }

      drawRoomNumber(roomLabel, floorBase, numberShade, roomDefs[roomIndex].label === 1);

      if (roomDefs[roomIndex].label === 1) {
        for (let y = 0; y < GRID; y++) {
          for (let x = 0; x < GRID; x++) {
            const t = rooms[roomIndex][y][x];
            if (t !== 0) continue;
            const seed = (x * 29 + y * 53) % 7;
            if (seed <= 2) {
              ctx.fillStyle = "#165a4c";
              ctx.fillRect(x * TILE + 2, y * TILE + 3, 2, 2);
              ctx.fillRect(x * TILE + 10, y * TILE + 8, 2, 2);
            } else if (seed === 3) {
              ctx.fillStyle = "#1ebc73";
              ctx.fillRect(x * TILE + 6, y * TILE + 2, 1, 3);
              ctx.fillRect(x * TILE + 9, y * TILE + 10, 1, 2);
            } else if (seed === 4) {
              ctx.fillStyle = "#165a4c";
              ctx.fillRect(x * TILE + 4, y * TILE + 9, 1, 3);
              ctx.fillRect(x * TILE + 5, y * TILE + 8, 1, 2);
              ctx.fillRect(x * TILE + 6, y * TILE + 9, 1, 3);
            } else if (seed === 5) {
              ctx.fillStyle = "#ff77a8";
              ctx.fillRect(x * TILE + 6, y * TILE + 6, 2, 2);
              ctx.fillStyle = "#ffec27";
              ctx.fillRect(x * TILE + 7, y * TILE + 7, 1, 1);
            }
          }
        }
      }

      if (roomDefs[roomIndex].label === 1 && treeImgReady) {
        ctx.drawImage(treeImg, TILE, TILE, TILE * 2, TILE * 2);
        ctx.drawImage(treeImg, TILE * 6, TILE, TILE * 2, TILE * 2);
        ctx.drawImage(treeImg, TILE, TILE * 6, TILE * 2, TILE * 2);
        ctx.drawImage(treeImg, TILE * 6, TILE * 6, TILE * 2, TILE * 2);
      }

      if (roomDefs[roomIndex].label === 10 && room10Watermelon && watermelonImgReady) {
        ctx.drawImage(watermelonImg, MID * TILE, MID * TILE, TILE, TILE);
      }

      // Draw walls/doors/buttons/grid
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          const t = rooms[roomIndex][y][x];

          if (t === 1) {
            ctx.fillStyle = "#1d2b53";
            ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
            ctx.fillStyle = "#5f574f";
            ctx.fillRect(x * TILE + 2, y * TILE + 2, TILE - 4, TILE - 4);

            if (roomDefs[roomIndex].label === 6 && y === 4 && (x === 3 || x === 5)) {
              ctx.fillStyle = "#ffec27";
              ctx.beginPath();
              if (x === 3) {
                ctx.moveTo(x * TILE + 4, y * TILE + 8);
                ctx.lineTo(x * TILE + 11, y * TILE + 4);
                ctx.lineTo(x * TILE + 11, y * TILE + 12);
              } else {
                ctx.moveTo(x * TILE + 12, y * TILE + 8);
                ctx.lineTo(x * TILE + 5, y * TILE + 4);
                ctx.lineTo(x * TILE + 5, y * TILE + 12);
              }
              ctx.closePath();
              ctx.fill();
            }
          }

          if (getDoorAt(roomIndex, x, y)) {
            ctx.fillStyle = "#1d2b53";
            ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
            ctx.fillStyle = "#ffccaa";
            ctx.fillRect(x * TILE + 3, y * TILE + 4, TILE - 6, TILE - 6);
            ctx.fillStyle = "#ab5236";
            ctx.fillRect(x * TILE + 6, y * TILE + 7, 2, 2);
          }

          if (roomIndex === 3 && room3Visited && x === ROOM4_BUTTON.x && y === ROOM4_BUTTON.y) {
            ctx.fillStyle = "#1d2b53";
            ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
            ctx.fillStyle = room4ButtonActive ? "#00e436" : "#ff004d";
            ctx.fillRect(x * TILE + 4, y * TILE + 4, TILE - 8, TILE - 8);
            ctx.fillStyle = "#000000";
            ctx.fillRect(x * TILE + 7, y * TILE + 7, 2, 2);
          }

          ctx.strokeStyle = "rgba(0,0,0,0.10)";
          ctx.strokeRect(x * TILE, y * TILE, TILE, TILE);
        }
      }

      // Draw player (simple 12x12 sprite centered in tile)
      const px = player.x * TILE;
      const hopPhase = 1 - Math.min(1, hopTimer / HOP_DURATION);
      const hopOffset = hopTimer > 0 ? Math.round(Math.sin(hopPhase * Math.PI) * 2) : 0;
      const py = player.y * TILE - hopOffset - 1;

      const hopScale = hopTimer > 0 ? 1 - (hopOffset / 6) : 1;
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.beginPath();
      ctx.ellipse(
        px + TILE / 2,
        player.y * TILE + TILE,
        6 * hopScale,
        2 * hopScale,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      if (playerImgReady) {
        ctx.save();
        ctx.translate(px + (facing === -1 ? TILE : 0), py);
        ctx.scale(facing, 1);
        ctx.drawImage(playerImg, 0, 0, TILE, TILE);
        ctx.restore();
      } else {
        ctx.fillStyle = "#ff004d";
        ctx.fillRect(px + 2, py + 2, TILE - 4, TILE - 4);

        ctx.fillStyle = "#fff1e8";
        ctx.fillRect(px + 4, py + 4, TILE - 8, TILE - 8);

        // ‚Äúface‚Äù dot
        ctx.fillStyle = "#1d2b53";
        ctx.fillRect(px + 10, py + 6, 2, 2);
      }

      if (transition.alpha > 0) {
        ctx.fillStyle = `rgba(0,0,0,${transition.alpha})`;
        ctx.fillRect(0, 0, W, H);
      }

      const room6PathLabel = room6Path ? room6Path : "none";
      statusEl.textContent = `x: ${player.x}, y: ${player.y}`;
      room6DebugEl.textContent = `room6Path: ${room6PathLabel}`;
      roomLabelEl.textContent = `Room ${roomDefs[roomIndex].label}`;
    }

    const digitMap = {
      "0": ["111","101","101","101","111"],
      "1": ["010","110","010","010","111"],
      "2": ["111","001","111","100","111"],
      "3": ["111","001","111","001","111"],
      "4": ["101","101","111","001","001"],
      "5": ["111","100","111","001","111"],
      "6": ["111","100","111","101","111"],
      "7": ["111","001","001","010","010"],
      "8": ["111","101","111","101","111"],
      "9": ["111","101","111","001","111"],
    };

    function drawRoomNumber(text, base, shade, isRoomOne) {
      const digitW = 3;
      const digitH = 5;
      const gap = 1;
      const totalW = text.length * digitW + (text.length - 1) * gap;
      const startX = Math.floor((GRID - totalW) / 2);
      const startY = 2;

      for (let i = 0; i < text.length; i++) {
        const glyph = digitMap[text[i]];
        if (!glyph) continue;
        const ox = startX + i * (digitW + gap);
        for (let gy = 0; gy < digitH; gy++) {
          for (let gx = 0; gx < digitW; gx++) {
            if (glyph[gy][gx] === "1") {
              const tx = ox + gx;
              const ty = startY + gy;
              if (rooms[roomIndex][ty][tx] !== 0) continue;
              ctx.fillStyle = base;
              ctx.fillRect(tx * TILE, ty * TILE, TILE, TILE);
              ctx.fillStyle = isRoomOne ? "rgba(0,0,0,0.07)" : shade;
              ctx.fillRect(tx * TILE, ty * TILE, TILE, TILE);
            }
          }
        }
      }
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
