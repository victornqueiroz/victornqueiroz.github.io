<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>5x5 Tile Prototype</title>
  <style>
    :root { color-scheme: dark; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: clamp(12px, 4vw, 30px);
      box-sizing: border-box;
      background: #0f172a;
      color: #e5e7eb;
    }
    .layout {
      display: grid;
      grid-template-columns: 1fr minmax(0, 600px) minmax(260px, 360px);
      gap: clamp(12px, 3vw, 24px);
      width: 100%;
      max-width: 1200px;
      align-items: start;
    }
    .col-empty { min-height: 1px; }
    .col-main { display: flex; flex-direction: column; align-items: center; }
    .col-guide {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 18px;
      padding: 16px;
      color: #f1f5f9;
      height: fit-content;
      margin-top: 27%;
    }
    .col-guide h2 {
      margin: 0 0 12px;
      font-size: 18px;
      text-align: center;
    }
    .guide-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .guide-table th, .guide-table td {
      border-bottom: 1px solid #1e293b;
      padding: 6px 4px;
      text-align: center;
      white-space: nowrap;
    }
    .guide-table tr:last-child td { border-bottom: none; }
    @media (max-width: 960px) {
      .layout {
        grid-template-columns: 1fr;
      }
      .col-guide { order: 3; }
      .col-empty { display: none; }
    }
    .info { margin-bottom: 10px; text-align: center; max-width: 460px; }
    .board-wrapper, .scoreboard, .panel { width: min(94vw, 480px); }
    .board-wrapper { margin-top: 10px; }
    .board {
      width: 100%;
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: clamp(4px, 1vw, 8px);
      position: relative;
    }
    .cell {
      width: 100%; aspect-ratio: 1 / 1; border-radius: 10px;
      background: #1e293b; border: 1px solid #334155;
      display: flex; align-items: center; justify-content: center;
      font-size: clamp(22px, 4.5vw, 28px); cursor: pointer;
      transition: transform 0.06s ease, box-shadow 0.06s ease, background 0.1s ease;
      box-shadow: 0 2px 4px rgba(15, 23, 42, 0.6);
      user-select: none;
      position: relative;
    }
    .tile-content {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .cell.inner { background: #1e293b; }
    .cell.offboard { background: #0f172a; border-style: dashed; }
    .cell.dead { background: #030712; border-color: #111827; cursor: default; opacity: 0.4; }
    .cell:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(15, 23, 42, 0.8);
      background: #111827;
    }
    .cell.disabled { cursor: default; opacity: 0.6; }
    .panel {
      margin: 30px auto; padding: 12px 18px; border-radius: 18px;
      background: #1f2937; border: 1px solid #4b5563;
      display: flex; align-items: center; gap: 16px;
      font-size: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .current-tile {
      font-size: 28px; padding: 4px 14px; border-radius: 999px;
      background: #111827; border: 1px solid #4b5563; min-width: 50px;
      text-align: center;
    }
    .btn-row { margin-top: 14px; display: flex; gap: 10px; }
    button {
      background: #22c55e; color: #022c22; border: none;
      border-radius: 999px; padding: 8px 16px; font-size: 14px;
      cursor: pointer; font-weight: 600;
    }
    button.secondary { background: #4b5563; color: #e5e7eb; }
    .scoreboard {
      margin: 16px 0;
      display: flex;
      gap: clamp(12px, 3vw, 20px);
      background: #111827;
      padding: clamp(10px, 3vw, 18px);
      border-radius: 18px;
      border: 1px solid #1f2937;
      align-items: stretch;
      flex-wrap: nowrap;
    }
    .score-heading {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #94a3b8;
      margin-bottom: 6px;
    }
    .calc-column { flex: 1.2 1 0; min-width: 0; }
    .score-column { flex: 0.6 1 0; text-align: center; }
    .score-value {
      font-size: clamp(28px, 6vw, 40px);
      font-weight: 700;
    }
    .turn-log { display: flex; flex-direction: column; gap: 6px; font-size: 14px; min-width: 0; min-height: 60px; }
    .turn-values { display: grid; grid-template-columns: auto auto auto; justify-content: center; gap: 6px; align-items: baseline; font-size: 24px; font-weight: 600; }
    .turn-values span { text-align: center; min-width: 50px; }
    .turn-multiply-symbol { min-width: 20px; }
    .turn-result { font-size: 24px; font-weight: 700; text-align: center; min-height: 28px; opacity: 0; transition: opacity 0.2s ease; }
    .turn-tiles {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 12px;
      font-size: 14px;
      min-height: 36px;
      margin-top:13px;
    }
    .turn-nature, .turn-items {
      min-height: 32px;
      text-align: left;
    }
    .turn-nature span, .turn-items span {
      padding: 0;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.18s ease, transform 0.18s ease;
    }
    .calc-consuming { opacity: 0; transform: scale(0.4); }
    .score-bump {
      animation: scoreBump 0.35s ease;
    }
    @keyframes scoreBump {
      0% { transform: translateY(0) scale(1); }
      25% { transform: translateY(-4px) scale(1.1); }
      60% { transform: translateY(0) scale(0.95); }
      80% { transform: translateY(-2px) scale(1.04); }
      100% { transform: translateY(0) scale(1); }
    }
    #totalScore { font-size: clamp(28px, 5vw, 36px); font-weight: 700; }
    @media (max-width: 540px) {
      h1 { font-size: clamp(22px, 6vw, 26px); text-align: center; }
      .scoreboard { flex-direction: column; align-items: stretch; }
      .score-column { text-align: left; }
      .panel { flex-direction: column; border-radius: 18px; }
      .info { font-size: 14px; }
    }
    .tile-base { font-size: clamp(24px, 4vw, 28px); line-height: 1; }
    .tile-attachment-food,
    .tile-attachment-insect {
      position: absolute;
      font-size: 16px;
      line-height: 1;
    }
    .tile-attachment-food {
      top: 6px;
      right: 6px;
    }
    .tile-attachment-insect {
      bottom: 6px;
      right: 6px;
    }
    .cell.clearing {
      animation: fadeOut 0.25s forwards;
    }
    .tile-feedback {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translate(-50%, -60%);
      background: #030712;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: clamp(16px, 3.6vw, 22px);
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      z-index: 25;
      color: #f8fafc;
      white-space: nowrap;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .tile-feedback.visible {
      opacity: 1;
      transform: translate(-50%, -110%);
    }
    .tile-content span {
      transition: opacity 0.28s ease, transform 0.28s ease;
    }
    .consuming-piece {
      opacity: 0 !important;
      transform: scale(0.4) !important;
    }
    @keyframes fadeOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    .flyover-bird {
      position: absolute;
      width: calc(100% / 7);
      height: calc(100% / 7);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(24px, 5vw, 34px);
      pointer-events: none;
      opacity: 0;
      transform: translate(-9999px, -9999px);
      transition: transform 0.22s ease, opacity 0.15s ease;
    }
    .flyover-bird.active {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="layout">
    <div class="col-empty"></div>
    <div class="col-main">
      <h1>Wildforest</h1>
      <div class="scoreboard">
        <div class="calc-column">
          <div id="turnLog" class="turn-log"></div>
        </div>
        <div class="score-column">
          <div class="score-heading">Total Score</div>
          <div class="score-value" id="totalScore">0</div>
        </div>
      </div>
      
      <div class="board-wrapper">
        <div id="board" class="board"></div>
      </div>
      <div class="panel">
        <span>Current tile:</span>
        <span id="currentTile" class="current-tile">?</span>
        <span>Turns:</span>
        <span id="placedCount">0</span> / <span id="totalPlayable">0</span>
      </div>
    </div>
    <div class="col-guide">
      <h2>Quick Guide</h2>
      <table class="guide-table">
        <thead>
          <tr>
            <th>Emoji</th>
            <th>Score</th>
            <th>How to gain</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>ğŸŒ¿</td><td>10</td><td>basic</td></tr>
          <tr><td>ğŸ’§</td><td>20</td><td>basic</td></tr>
          <tr><td>ğŸŒ±</td><td>10</td><td>basic</td></tr>
          <tr><td>ğŸŒ³</td><td>30</td><td>ğŸŒ¿ + ğŸŒ¿</td></tr>
          <tr><td>ğŸŒ»</td><td>30</td><td>ğŸŒ± + ğŸŒ±</td></tr>
          <tr><td>ğŸªµ</td><td>50</td><td>ğŸŒ³ â†’ ğŸªµ</td></tr>
          <tr><td>ğŸŸ</td><td>100</td><td>ğŸ’§ + ğŸ’§</td></tr>
          <tr><td>ğŸª·</td><td>200</td><td>ğŸŒ» + ğŸ’§</td></tr>
          <tr><td>ğŸ</td><td>100</td><td>ğŸŒ³ + ğŸŒ³ / ğŸ’§ + ğŸŒ³</td></tr>
          <tr><td>ğŸŒ¼</td><td>100</td><td>ğŸŒ» + ğŸŒ» / ğŸ’§ + ğŸŒ»</td></tr>
          <tr><td>ğŸ«˜</td><td>200</td><td>ğŸŒ³ + ğŸŒ»</td></tr>
          <tr><td>ğŸ„</td><td>2000 </td><td>ğŸªµ + ğŸªµ / ğŸ’§ + ğŸªµ</td></tr>
          <tr><td>ğŸ•·ï¸</td><td>+2 mult</td><td>ğŸŒ³ + ğŸ’§</td></tr>
          <tr><td>ğŸ¦‹</td><td>+3 mult</td><td>ğŸŒ» + ğŸŒ³</td></tr>
          <tr><td>ğŸŒ</td><td>points Ã—3</td><td>ğŸªµ + ğŸ’§</td></tr>
          <tr><td>ğŸ</td><td>mult Ã—3</td><td>ğŸªµ + ğŸŒ»</td></tr>
          <tr><td>ğŸœ</td><td>+7 mult</td><td>ğŸªµ + ğŸŒ³</td></tr>
          <tr><td>ğŸ›</td><td>+7 mult</td><td>ğŸŒ» + ğŸªµ</td></tr>
          <tr><td>ğŸ¦‚</td><td>mult Ã—5</td><td>ğŸŒ³ + ğŸªµ</td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <script>
    const SIZE = 7;
    const INNER_START = 1;
    const INNER_END = SIZE - 2;
    const BIRD_TILE = "ğŸ¦";
    let board = [];
    const naturePool = [
      { tile: "ğŸŒ¿", weight: 0.30 },
      { tile: "ğŸ’§", weight: 0.30 },
      { tile: "ğŸŒ±", weight: 0.30 },
      { tile: "ğŸŒ³", weight: 0.04 },
      { tile: "ğŸŒ»", weight: 0.04 },
      { tile: "ğŸªµ", weight: 0.02 },
    ];
    let currentTile = null;
    let placedCount = 0;
    const totalPlayable = (SIZE - 2) * (SIZE + 2);
    let isAnimating = false;
    const FLYOVER_STEP_MS = 200;
    const FLYOVER_FAST_MS = 200;
    const FLYOVER_FADE_MS = 10;
    const FEEDBACK_VISIBLE_MS = 600;
    const FEEDBACK_FADE_MS = 450;
    const CONSUME_FADE_MS = 300;
    let turnBaseScore = 0;
    let turnInsectCount = 0;
    let turnFinalized = false;
    let totalScore = 0;
    let scoreTransferring = false;
    let scoreTransferTimer = null;
    let scoreTransferFrame = null;
    const SCORE_TRANSFER_DELAY = 700;
    const SCORE_TRANSFER_DURATION = 900;

    const natureDisplayOrder = ["ğŸŒ¿", "ğŸŒ±", "ğŸ’§", "ğŸŒ³", "ğŸŒ»", "ğŸªµ", "ğŸŸ", "ğŸŒ¼", "ğŸ", "ğŸª·", "ğŸ«˜", "ğŸ„"];
    const insectDisplayOrder = ["ğŸ•·ï¸", "ğŸ¦‹", "ğŸŒ", "ğŸ", "ğŸœ", "ğŸ¦‚", "ğŸ›"];

    const boardEl = document.getElementById("board");
    const currentTileEl = document.getElementById("currentTile");
    const placedCountEl = document.getElementById("placedCount");
    const totalPlayableEl = document.getElementById("totalPlayable");
    totalPlayableEl.textContent = totalPlayable;
    const turnLogEl = document.getElementById("turnLog");
    const totalScoreEl = document.getElementById("totalScore");
    const flyoverBirdEl = document.createElement("div");
    flyoverBirdEl.className = "flyover-bird";
    flyoverBirdEl.textContent = BIRD_TILE;
    boardEl.appendChild(flyoverBirdEl);
    ensureTurnDisplayInitialized();

    const TILE_POINTS = {
      "": 0,
      "ğŸŒ¿": 10,
      "ğŸŒ±": 10,
      "ğŸ’§": 20,
      "ğŸŒ³": 30,
      "ğŸŒ»": 30,
      "ğŸªµ": 50,
      "ğŸŸ": 100,
      "ğŸŒ¼": 100,
      "ğŸ": 100,
      "ğŸª·": 200,
      "ğŸ«˜": 200,
      "ğŸ„": 2000,
    };

    function initBoard() {
      cancelScoreTransferAnimation();
      scoreTransferring = false;
      boardEl.innerHTML = "";
      board = [];
      for (let r = 0; r < SIZE; r++) {
        const row = [];
        for (let c = 0; c < SIZE; c++) {
          row.push(null);
          const cell = document.createElement("div");
          cell.className = "cell";
          if (isCorner(r, c)) {
            cell.classList.add("dead");
          } else if (isOffboard(r, c)) {
            cell.classList.add("offboard");
          } else {
            cell.classList.add("inner");
          }
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.onclick = () => onCellClick(r, c);
          boardEl.appendChild(cell);
        }
        board.push(row);
      }
      boardEl.appendChild(flyoverBirdEl);
      placedCount = 0;
      placedCountEl.textContent = placedCount;
      rollNextTile();
      startTurnScore();
    }

    function rollNextTile() {
      const nextTurn = placedCount + 1;
      if (nextTurn % 6 === 0) {
        currentTile = BIRD_TILE;
      } else {
        currentTile = draftNatureTile();
      }
      currentTileEl.textContent = currentTile;
    }

    function draftNatureTile() {
      const roll = Math.random();
      let cumulative = 0;
      for (const entry of naturePool) {
        cumulative += entry.weight;
        if (roll < cumulative) return entry.tile;
      }
      return naturePool[naturePool.length - 1].tile;
    }

    function onCellClick(r, c) {
      if (isAnimating || scoreTransferring || !currentTile) return;
      if (!canPlaceHere(r, c)) return;
      startTurnScore();
      beginTurn();
      board[r][c] = createTile(currentTile);
      updateCell(r, c);
      placedCount++;
      placedCountEl.textContent = placedCount;
      if (currentTile === BIRD_TILE) {
        birdFlyover(r, c);
      } else {
        applyAdjacencyRules(r, c);
      }
      rollNextTile();
    }

    function cellIndex(r, c) {
      return r * SIZE + c;
    }

    function getCellElement(r, c) {
      return boardEl.children[cellIndex(r, c)];
    }

    function updateCell(r, c) {
      const cell = getCellElement(r, c);
      if (!cell) return;
      let content = cell.querySelector('.tile-content');
      if (!content) {
        content = document.createElement('div');
        content.className = 'tile-content';
        cell.innerHTML = '';
        cell.appendChild(content);
      }
      const tile = board[r][c];
      if (!tile) {
        content.innerHTML = '';
        return;
      }
      let html = tile.base ? `<span class="tile-base">${tile.base}</span>` : '';
      if (tile.foodAttachment) {
        html += `<span class="tile-attachment-food">${tile.foodAttachment}</span>`;
      }
      if (tile.insectAttachment) {
        html += `<span class="tile-attachment-insect">${tile.insectAttachment}</span>`;
      }
      content.innerHTML = html;
    }

    function neighbors(r, c) {
      return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([nr,nc]) =>
        nr>=0 && nr<SIZE && nc>=0 && nc<SIZE
      );
    }

    function isCorner(r, c) {
      const last = SIZE - 1;
      return (
        (r === 0 && c === 0) ||
        (r === 0 && c === last) ||
        (r === last && c === 0) ||
        (r === last && c === last)
      );
    }

    function isOffboard(r, c) {
      const last = SIZE - 1;
      if (isCorner(r, c)) return false;
      return r === 0 || c === 0 || r === last || c === last;
    }

    function isInner(r, c) {
      return r >= INNER_START && r <= INNER_END && c >= INNER_START && c <= INNER_END;
    }

    function canPlaceHere(r, c) {
      if (isCorner(r, c)) return false;
      if (board[r][c]) return false;
      if (currentTile === BIRD_TILE) {
        return isOffboard(r, c);
      }
      return isInner(r, c);
    }

    function createTile(base, overrides = {}) {
      return {
        base,
        foodAttachment: null,
        insectAttachment: null,
        shielded: false,
        attachmentCooldown: false,
        ...overrides,
      };
    }

    function beginTurn() {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const tile = board[r][c];
          if (tile) {
            tile.shielded = false;
            tile.attachmentCooldown = false;
          }
        }
      }
    }

    function transformNeighbor(sourceTile, targetTile) {
      if (!sourceTile || !targetTile || targetTile.shielded) return false;
      let changed = false;
      if (sourceTile.base === "ğŸŒ±" && targetTile.base === "ğŸŒ±") {
        targetTile.base = "ğŸŒ»";
        targetTile.foodAttachment = null;
        targetTile.insectAttachment = null;
        targetTile.attachmentCooldown = true;
        changed = true;
      } else if (sourceTile.base === "ğŸŒ¿" && targetTile.base === "ğŸŒ¿") {
        targetTile.base = "ğŸŒ³";
        targetTile.foodAttachment = null;
        targetTile.insectAttachment = null;
        targetTile.attachmentCooldown = true;
        changed = true;
      } else if (sourceTile.base === "ğŸ’§" && targetTile.base === "ğŸ’§") {
        changed = tryAddFoodAttachment(targetTile, "ğŸŸ") || changed;
      } else if (sourceTile.base === "ğŸŒ»" && targetTile.base === "ğŸ’§") {
        changed = tryAddFoodAttachment(targetTile, "ğŸª·") || changed;
      } else if (sourceTile.base === "ğŸŒ³" && targetTile.base === "ğŸŒ³") {
        changed = tryAddFoodAttachment(targetTile, "ğŸ") || changed;
      } else if (sourceTile.base === "ğŸ’§" && targetTile.base === "ğŸŒ³") {
        changed = tryAddFoodAttachment(targetTile, "ğŸ") || changed;
      } else if (sourceTile.base === "ğŸŒ»" && targetTile.base === "ğŸŒ»") {
        changed = tryAddFoodAttachment(targetTile, "ğŸŒ¼") || changed;
      } else if (sourceTile.base === "ğŸ’§" && targetTile.base === "ğŸŒ»") {
        changed = tryAddFoodAttachment(targetTile, "ğŸŒ¼") || changed;
      } else if (sourceTile.base === "ğŸŒ³" && targetTile.base === "ğŸŒ»") {
        changed = tryAddFoodAttachment(targetTile, "ğŸ«˜") || changed;
      } else if (sourceTile.base === "ğŸŒ³" && targetTile.base === "ğŸ’§") {
        changed = tryAddInsectAttachment(targetTile, "ğŸ•·ï¸") || changed;
      } else if (sourceTile.base === "ğŸŒ»" && targetTile.base === "ğŸŒ³") {
        changed = tryAddInsectAttachment(targetTile, "ğŸ¦‹") || changed;
      } else if (sourceTile.base === "ğŸªµ" && targetTile.base === "ğŸ’§") {
        changed = tryAddInsectAttachment(targetTile, "ğŸŒ") || changed;
      } else if (sourceTile.base === "ğŸªµ" && targetTile.base === "ğŸŒ³") {
        changed = tryAddInsectAttachment(targetTile, "ğŸœ") || changed;
      } else if (sourceTile.base === "ğŸªµ" && targetTile.base === "ğŸŒ»") {
        changed = tryAddInsectAttachment(targetTile, "ğŸ") || changed;
      } else if (sourceTile.base === "ğŸªµ" && targetTile.base === "ğŸªµ") {
        changed = tryAddFoodAttachment(targetTile, "ğŸ„") || changed;
      } else if (sourceTile.base === "ğŸŒ³" && targetTile.base === "ğŸªµ") {
        changed = tryAddInsectAttachment(targetTile, "ğŸ¦‚") || changed;
      } else if (sourceTile.base === "ğŸŒ»" && targetTile.base === "ğŸªµ") {
        changed = tryAddInsectAttachment(targetTile, "ğŸ›") || changed;
      } else if (sourceTile.base === "ğŸ’§" && targetTile.base === "ğŸªµ") {
        changed = tryAddFoodAttachment(targetTile, "ğŸ„") || changed;
      }
      return changed;
    }

    function tryAddFoodAttachment(tile, attachment) {
      if (tile.attachmentCooldown) return false;
      if (tile.foodAttachment && tile.foodAttachment === attachment) return false;
      if (tile.foodAttachment) return false;
      tile.foodAttachment = attachment;
      return applyAttachmentShield(tile);
    }

    function tryAddInsectAttachment(tile, attachment) {
      if (tile.attachmentCooldown) return false;
      if (tile.insectAttachment && tile.insectAttachment === attachment) return false;
      if (tile.insectAttachment) return false;
      tile.insectAttachment = attachment;
      return applyAttachmentShield(tile);
    }

    function applyAttachmentShield(tile) {
      tile.attachmentCooldown = true;
      tile.shielded = true;
      return true;
    }

    function applyAdjacencyRules(r, c) {
      const queue = [[r, c]];
      while (queue.length) {
        const [cr, cc] = queue.shift();
        const tile = board[cr][cc];
        if (!tile || tile.shielded) continue;
        neighbors(cr, cc).forEach(([nr, nc]) => {
          const existing = board[nr][nc];
          if (transformNeighbor(tile, existing)) {
            updateCell(nr, nc);
            queue.push([nr, nc]);
          }
        });
      }
    }

    async function birdFlyover(r, c) {
      const targets = [];
      if (r === 0) {
        for (let row = INNER_START; row <= INNER_END; row++) targets.push([row, c]);
      } else if (r === SIZE - 1) {
        for (let row = INNER_END; row >= INNER_START; row--) targets.push([row, c]);
      } else if (c === 0) {
        for (let col = INNER_START; col <= INNER_END; col++) targets.push([r, col]);
      } else if (c === SIZE - 1) {
        for (let col = INNER_END; col >= INNER_START; col--) targets.push([r, col]);
      }
      if (!targets.length) {
        finalizeBirdFlight(r, c);
        return;
      }
      isAnimating = true;
      flyoverBirdEl.classList.add("active");
      board[r][c] = null;
      updateCell(r, c);
      moveFlyoverBirdTo(r, c);
      await wait(FLYOVER_FAST_MS);
      for (let i = 0; i < targets.length; i++) {
        const [tr, tc] = targets[i];
        moveFlyoverBirdTo(tr, tc);
        const tile = board[tr][tc];
        const travelTime = tile ? FLYOVER_STEP_MS : FLYOVER_FAST_MS;
        await wait(travelTime);
        if (tile) {
          await fadeOutCell(tr, tc);
        }
      }
      finalizeBirdFlight(r, c);
    }

    function finalizeBirdFlight(r, c) {
      board[r][c] = null;
      updateCell(r, c);
      flyoverBirdEl.classList.remove("active");
      flyoverBirdEl.style.transform = "translate(-9999px, -9999px)";
      isAnimating = false;
      finalizeTurnScore();
    }

    function moveFlyoverBirdTo(r, c) {
      const cell = getCellElement(r, c);
      if (!cell) return;
      const boardRect = boardEl.getBoundingClientRect();
      const cellRect = cell.getBoundingClientRect();
      const x = cellRect.left - boardRect.left;
      const y = cellRect.top - boardRect.top;
      flyoverBirdEl.style.transform = `translate(${x}px, ${y}px)`;
    }

    function fadeOutCell(r, c) {
      return new Promise((resolve) => {
        const cell = getCellElement(r, c);
        const tile = board[r][c];
        if (!cell || !tile) {
          resolve();
          return;
        }
        const { events } = addTurnScoreFromTile(tile);
        showTileFeedbackSequence(cell, events, tile, r, c).then(() => {
          const replacement = tile && tile._spawnReplacement ? tile._spawnReplacement : null;
          cell.classList.add("clearing");
          setTimeout(() => {
            board[r][c] = replacement;
            if (replacement) delete tile._spawnReplacement;
            updateCell(r, c);
            cell.classList.remove("clearing");
            resolve();
          }, FLYOVER_FADE_MS);
        });
      });
    }

    function startTurnScore() {
      turnBaseScore = 0;
      turnInsectCount = 1;
      turnFinalized = false;
      ensureTurnDisplayInitialized();
      const turnPointsEl = document.getElementById("turnPoints");
      const turnMultiplierEl = document.getElementById("turnMultiplier");
      const turnResultEl = document.getElementById("turnResult");
      const natureEl = document.getElementById("turnNature");
      const itemsEl = document.getElementById("turnItems");
      if (turnPointsEl) turnPointsEl.textContent = 0;
      if (turnMultiplierEl) turnMultiplierEl.textContent = 0;
      if (turnResultEl) {
        turnResultEl.textContent = "";
        turnResultEl.style.opacity = 0;
      }
      if (natureEl) natureEl.innerHTML = "";
      if (itemsEl) itemsEl.innerHTML = "";
    }

    function addTurnScoreFromTile(tile) {
      const events = [];
      const base = TILE_POINTS[tile.base] || 0;
      if (base > 0) events.push({ type: "points", amount: base, origin: "base", emoji: tile.base });
      if (tile.foodAttachment) {
        const foodPoints = TILE_POINTS[tile.foodAttachment] || 0;
        if (foodPoints > 0) events.push({ type: "points", amount: foodPoints, origin: "food", emoji: tile.foodAttachment });
      }
      if (tile.insectAttachment) {
        const insectEvent = getInsectEventData(tile.insectAttachment);
        if (insectEvent) events.push({ type: "mult", origin: "insect", emoji: tile.insectAttachment, ...insectEvent });
      }
      events.sort((a, b) => eventPriority(a.origin) - eventPriority(b.origin));
      ensureTurnDisplayInitialized();
      return { events };
    }

    function ensureTurnDisplayInitialized() {
      if (document.getElementById("turnPoints")) return;
      turnLogEl.innerHTML = `
        <div id="turnResult" class="turn-result">0</div>
        <div class="turn-values">
          <span id="turnPoints">0</span>
          <span class="turn-multiply-symbol">Ã—</span>
          <span id="turnMultiplier">0</span>
        </div>
        <div id="turnTiles" class="turn-tiles">
          <div class="turn-nature" id="turnNature"></div>
          <div class="turn-items" id="turnItems"></div>
        </div>
      `;
    }

    function insertEmojiOrdered(container, emoji, order) {
      if (!emoji) return;
      const spans = Array.from(container.children);
      let insertIndex = spans.length;
      spans.some((span, idx) => {
        const curr = span.dataset.emoji || span.textContent;
        if (orderIndex(order, emoji) < orderIndex(order, curr)) {
          insertIndex = idx;
          return true;
        }
        return false;
      });
      const span = document.createElement("span");
      span.dataset.emoji = emoji;
      span.textContent = emoji;
      if (insertIndex >= spans.length) {
        container.appendChild(span);
      } else {
        container.insertBefore(span, spans[insertIndex]);
      }
    }

    function orderIndex(order, emoji) {
      const idx = order.indexOf(emoji);
      return idx === -1 ? order.length : idx;
    }

    function eventPriority(origin) {
      if (origin === "food") return 0;
      if (origin === "insect") return 1;
      return 2;
    }

    function getInsectEventData(emoji) {
      switch (emoji) {
        case "ğŸ•·ï¸":
          return { amount: 2, label: "+2 mult", mode: "addMult" };
        case "ğŸ¦‹":
          return { amount: 3, label: "+3 mult", mode: "addMult" };
        case "ğŸŒ":
          return { amount: 3, label: "Ã—3 pts", mode: "pointsFactor" };
        case "ğŸ":
          return { amount: 3, label: "Ã—3 mult", mode: "multFactor" };
        case "ğŸ¦‚":
          return { amount: 5, label: "Ã—5 mult", mode: "multFactor" };
        case "ğŸœ":
        case "ğŸ›":
          return { amount: 7, label: "+7 mult", mode: "addMult" };
        default:
          return null;
      }
    }

    function showTileFeedbackSequence(cell, events, tile, r, c) {
      if (!events || !events.length) return Promise.resolve();
      return events.reduce((promise, event) => {
        return promise.then(() =>
          showTileFeedback(cell, event, () => {
            appendEventEmoji(event);
            consumeTilePart(tile, event, r, c);
          })
        );
      }, Promise.resolve());
    }

    function showTileFeedback(cell, event, onReveal) {
      return new Promise((resolve) => {
        const amountValue = resolveEventAmount(event);
        const bubble = document.createElement("div");
        bubble.className = "tile-feedback";
        const label =
          event.label ||
          (event.mode === "multFactor"
            ? `Ã—${amountValue} mult`
            : event.mode === "pointsFactor"
            ? `Ã—${amountValue} pts`
            : event.mode === "addMult" || event.type === "mult"
            ? `+${amountValue} mult`
            : `+${amountValue}`);
        bubble.textContent = label;
        bubble.dataset.type = event.type;
        bubble.dataset.amount = amountValue;
        cell.appendChild(bubble);
        requestAnimationFrame(() => {
          bubble.classList.add("visible");
          if (onReveal) onReveal();
          applyEventToScore(event, amountValue);
        });
        setTimeout(() => {
          bubble.classList.remove("visible");
          setTimeout(() => {
            bubble.remove();
            resolve();
          }, FEEDBACK_FADE_MS);
        }, FEEDBACK_VISIBLE_MS);
      });
    }

    function consumeTilePart(tile, event, r, c) {
      if (!tile) return;
      const cell = getCellElement(r, c);
      const content = cell ? cell.querySelector('.tile-content') : null;
      let selector = '';
      if (event.origin === "base") {
        selector = '.tile-base';
        if (event.emoji === "ğŸŒ³" && Math.random() < 0.5) {
          tile._spawnReplacement = createTile("ğŸªµ");
        }
        tile.base = "";
      } else if (event.origin === "food") {
        selector = '.tile-attachment-food';
        tile.foodAttachment = null;
      } else if (event.origin === "insect") {
        selector = '.tile-attachment-insect';
        tile.insectAttachment = null;
      }
      const target = content ? content.querySelector(selector) : null;
      if (target) {
        target.classList.add('consuming-piece');
        setTimeout(() => updateCell(r, c), CONSUME_FADE_MS);
      } else {
        updateCell(r, c);
      }
    }

    function appendEventEmoji(event) {
      if (!event || !event.emoji) return;
      const natureEl = document.getElementById("turnNature");
      const itemsEl = document.getElementById("turnItems");
      const container = event.origin === "insect" ? itemsEl : natureEl;
      if (!container) return;
      const span = document.createElement("span");
      span.textContent = event.emoji;
      container.appendChild(span);
    }

    function resolveEventAmount(event) {
      if (!event) return 0;
      if (typeof event.amountFn === "function") return Math.round(event.amountFn());
      return event.amount || 0;
    }

    function applyEventToScore(event, amountValue) {
      if (!event) return;
      const amount = amountValue ?? resolveEventAmount(event);
      if (event.mode === "pointsFactor") {
        turnBaseScore = Math.round(Math.max(0, turnBaseScore) * amount);
        bumpElement(document.getElementById("turnPoints"));
      } else if (event.mode === "multFactor") {
        turnInsectCount = Math.max(1, turnInsectCount) * amount;
        bumpElement(document.getElementById("turnMultiplier"));
      } else if (event.mode === "addMult" || event.type === "mult") {
        turnInsectCount += amount;
        bumpElement(document.getElementById("turnMultiplier"));
      } else if (event.type === "points") {
        turnBaseScore += amount;
        bumpElement(document.getElementById("turnPoints"));
      }
      updateTurnFinal({ maskMultiplier: false });
    }

    function bumpElement(el) {
      if (!el) return;
      el.classList.remove("score-bump");
      void el.offsetWidth;
      el.classList.add("score-bump");
    }

    function currentMultiplier() {
      return Math.max(1, turnInsectCount || 1);
    }

    function updateTurnFinal({ maskMultiplier = false } = {}) {
      const rawMult = currentMultiplier();
      const displayMult = maskMultiplier ? 0 : rawMult;
      const subtotal = turnBaseScore * rawMult;
      const turnPointsEl = document.getElementById("turnPoints");
      const turnMultiplierEl = document.getElementById("turnMultiplier");
      if (turnPointsEl) turnPointsEl.textContent = turnBaseScore;
      if (turnMultiplierEl) turnMultiplierEl.textContent = displayMult;
    }

    function finalizeTurnScore() {
      if (turnFinalized) return;
      turnFinalized = true;
      ensureTurnDisplayInitialized();
      const finalScore = turnBaseScore * currentMultiplier();
      const turnPointsEl = document.getElementById("turnPoints");
      const turnMultiplierEl = document.getElementById("turnMultiplier");
      const turnResultEl = document.getElementById("turnResult");
      if (turnPointsEl) turnPointsEl.textContent = 0;
      if (turnMultiplierEl) turnMultiplierEl.textContent = 0;
      const showResultThenTransfer = () => {
        if (turnResultEl) {
          turnResultEl.textContent = `${finalScore}`;
          turnResultEl.style.opacity = 1;
          bumpElement(turnResultEl);
        }
        beginScoreTransfer(finalScore).then(clearTurnTileEmojis);
      };
      showResultThenTransfer();
    }

    function beginScoreTransfer(amount) {
      cancelScoreTransferAnimation();
      const turnResultEl = document.getElementById("turnResult");
      if (amount <= 0) {
        if (turnResultEl) {
          turnResultEl.textContent = 0;
          turnResultEl.style.opacity = 0;
        }
        scoreTransferring = false;
        return Promise.resolve();
      }
      scoreTransferring = true;
      const startTotal = totalScore;
      const startAmount = amount;
      return new Promise((resolve) => {
        scoreTransferTimer = setTimeout(() => {
          const startTime = performance.now();
          const step = (now) => {
            const progress = Math.min(1, (now - startTime) / SCORE_TRANSFER_DURATION);
            const gained = Math.round(startAmount * progress);
            totalScoreEl.textContent = startTotal + gained;
            if (turnResultEl) turnResultEl.textContent = Math.max(0, startAmount - gained);
            if (progress < 1) {
              scoreTransferFrame = requestAnimationFrame(step);
            } else {
              totalScore = startTotal + startAmount;
              totalScoreEl.textContent = totalScore;
              if (turnResultEl) {
                turnResultEl.textContent = 0;
                turnResultEl.style.opacity = 0;
              }
              scoreTransferring = false;
              scoreTransferFrame = null;
              resolve();
            }
          };
          scoreTransferFrame = requestAnimationFrame(step);
        }, SCORE_TRANSFER_DELAY);
      });
    }

    function cancelScoreTransferAnimation() {
      if (scoreTransferTimer) {
        clearTimeout(scoreTransferTimer);
        scoreTransferTimer = null;
      }
      if (scoreTransferFrame) {
        cancelAnimationFrame(scoreTransferFrame);
        scoreTransferFrame = null;
      }
      scoreTransferring = false;
    }

    function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function clearTurnTileEmojis() {
      const itemsEl = document.getElementById("turnItems");
      const natureEl = document.getElementById("turnNature");
      const sequence = [
        ...(itemsEl ? Array.from(itemsEl.querySelectorAll("span")).reverse() : []),
        ...(natureEl ? Array.from(natureEl.querySelectorAll("span")).reverse() : []),
      ];
      return sequence.reduce((promise, span) => {
        return promise.then(() => new Promise((resolve) => {
          span.classList.add("calc-consuming");
          setTimeout(() => {
            span.remove();
            resolve();
          }, 160);
        }));
      }, Promise.resolve());
    }

    initBoard();
  </script>
</body>
</html>
